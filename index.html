<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Agent Interaction Evaluation (v1.9.5 - Simplified Titles)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            line-height: 1.6; margin: 0; padding: 20px; background-color: #f0f2f5; color: #1c1e21;
        }
        .main-container { max-width: 1300px; margin: auto; background: #fff; padding: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1), 0 8px 16px rgba(0,0,0,0.1); }

        /* Navigation and Progress */
        .navigation-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 1px solid #dddfe2; }
        .progress-bar-container { flex-grow: 1; margin: 0 20px; }
        .progress-bar { width: 100%; height: 20px; background-color: #e9ecef; border-radius: 10px; overflow: hidden; }
        .progress-bar-fill { height: 100%; width: 0%; background-color: #1877f2; border-radius: 10px; transition: width 0.5s ease-in-out; text-align: center; color: white; font-size: 0.8em; line-height: 20px; }
        .nav-button { padding: 8px 15px; font-size: 14px; background-color: #6c757d; color: white; border: none; border-radius: 5px; cursor: pointer; }
        .nav-button:hover { background-color: #5a6268; }
        .nav-button:disabled { background-color: #ccc; cursor: not-allowed;}

        /* Screens */
        .selection-screen h2 { margin-bottom: 20px; text-align: center; color: #1877f2;}
        .hidden { display: none; }

        /* Task Information Display */
        .task-info-display { margin-bottom: 15px; padding: 15px; border: 1px solid #dddfe2; border-radius: 8px; background-color: #f7f8fa; }
        .task-info-display h4 { margin-top: 0; color: #1c1e21; font-size: 1.1em; margin-bottom: 8px; padding: 5px; background-color: #e9f5ff; border-radius: 4px;}
        .task-info-display h5 { margin-top: 10px; color: #4b4f56; font-size: 1em; margin-bottom: 5px;} /* Used within collapsible details */
        .task-info-display h6 { margin-top: 8px; color: #606770; font-size: 0.95em; margin-bottom: 3px;} /* Used for sub-subsections */

        .context-display, .question-display, .options-display, .conversation-turns-display, .context-hint-display {
            border: 1px dashed #007bff; padding: 10px; margin-bottom: 10px; background-color: #e9f5ff;
            max-height: 250px; overflow-y: auto; font-size: 0.9em; white-space: pre-wrap; word-break: break-word;
        }
        .question-display { font-weight: bold; background-color: #d1e7fd;}
        .options-display { background-color: #f8f9fa; border-color: #adb5bd; max-height: 300px; }
        .context-hint-display { background-color: #fffbe6; border-color: #ffc107; } /* For context_hint */
        .option-item { margin-bottom: 5px; padding-left: 10px; }
        .option-item strong { margin-right: 5px; }
        .correct-option { background-color: #d4edda; color: #155724; padding: 2px 5px; border-radius: 3px; font-weight: bold;}

        .conversation-turns-display { border-color: #28a745; background-color: #e6ffed; max-height: 400px; }
        .conversation-turn { margin-bottom: 8px; padding: 5px; border-left: 3px solid #198754; background-color: #fafffc; }
        .conversation-turn strong { color: #0a58ca; }

        /* Collapsible Sections */
        .collapsible-section { margin-bottom: 15px; border: 1px solid #dddfe2; border-radius: 6px; background-color: #fdfdfd; }
        .collapsible-header { background-color: #e9ecef; padding: 10px 15px; cursor: pointer; border-bottom: 1px solid #dddfe2; border-radius: 5px 5px 0 0; display: flex; justify-content: space-between; align-items: center; font-weight: bold; color: #495057; }
        .collapsible-header:hover { background-color: #dde2e6; }
        .collapsible-content { padding: 0 15px 15px 15px; display: none; border-top: none; max-height: 400px; overflow-y: auto; }
        .collapsible-content.show { display: block; }
        .collapsible-arrow { font-size: 0.8em; transition: transform 0.2s ease-in-out; margin-left: auto; padding-left: 10px; }
        .collapsible-header.open .collapsible-arrow { transform: rotate(90deg); }
        .collapsible-content .context-display { margin-top: 10px; } /* Spacing for pre tags inside collapsibles */

        /* Agent Interaction Area */
        .situation-prompt { text-align: center; font-style: italic; color: #606770; margin-bottom: 20px; padding: 10px; background-color: #e9f5ff; border: 1px solid #cfe2ff; border-radius: 6px; }
        .agents-container { display: flex; justify-content: space-between; gap: 20px; margin-bottom: 30px; }
        .agent-column { flex: 1; border: 1px solid #dddfe2; border-radius: 8px; padding: 15px; background-color: #ffffff; box-shadow: 0 1px 2px rgba(0,0,0,0.1); min-width: 0; }
        .agent-column-header { text-align: center; font-weight: bold; color: #333; margin-bottom: 10px; padding-bottom: 5px; border-bottom: 1px solid #eee; }
        .conversation-area { height: 300px; overflow-y: auto; padding-right: 10px; scrollbar-width: thin; scrollbar-color: #ccc #f0f0f0; font-size: 0.95em; border: 1px solid #eee; background: #fdfdfd;}
        .conversation-area::-webkit-scrollbar { width: 8px; }
        .conversation-area::-webkit-scrollbar-track { background: #f0f0f0; border-radius: 4px;}
        .conversation-area::-webkit-scrollbar-thumb { background: #ccc; border-radius: 4px;}
        .message { display: flex; align-items: flex-start; margin-bottom: 12px; max-width: 98%; }
        .message-bubble { padding: 10px 14px; border-radius: 18px; word-wrap: break-word; line-height: 1.4; }
        .message.agent .message-bubble { background-color: #e4e6eb; color: #050505; border-radius: 18px 18px 18px 5px; }
        .message-emoji { font-size: 18px; margin-right: 8px; margin-top: 5px; }

        /* Evaluation Form */
        .evaluation-section { margin-top: 30px; padding: 20px; border: 1px solid #dddfe2; border-radius: 8px; background-color: #f7f8fa; }
        .evaluation-section h3 { text-align: center; color: #1877f2; margin-bottom: 20px; }
        .evaluation-question { margin-bottom: 25px; }
        .evaluation-question label.main-label { display: block; font-weight: bold; margin-bottom: 10px; color: #333; }
        .evaluation-question input[type="text"], .evaluation-question textarea { width: 100%; padding: 10px; border-radius: 6px; border: 1px solid #ccd0d5; box-sizing: border-box; font-size: 15px; }
        .evaluation-question textarea { min-height: 60px; resize: vertical; }
        .evaluation-section button.submit-feedback-btn { display: block; width: 250px; margin: 20px auto 0; padding: 12px 20px; font-size: 16px; background-color: #1877f2; color: white; border: none; border-radius: 6px; cursor: pointer; transition: background-color 0.3s; }
        .evaluation-section button.submit-feedback-btn:hover { background-color: #166fe5; }

        .rank-instructions { font-size: 0.9em; color: #606770; margin-bottom: 5px; }
        .rank-container { display: flex; flex-direction: row; justify-content: space-around; align-items: center; padding: 15px; border: 1px dashed #ccd0d5; border-radius: 6px; background-color: #fff; min-height: 70px; gap: 10px; }
        .rank-item { background-color: #e4e6eb; color: #050505; padding: 10px 15px; border-radius: 6px; cursor: grab; border: 1px solid #dddfe2; display: flex; align-items: center; text-align: center; min-width: 120px; box-shadow: 0 1px 1px rgba(0,0,0,0.05); font-size: 0.95em; }
        .rank-item.dragging { opacity: 0.5; background-color: #cfe2ff; transform: scale(1.05); }
        .rank-handle { font-size: 1.1em; margin-right: 8px; color: #606770; }

        .radio-group label { margin-right: 10px; font-weight: normal; cursor: pointer; font-size: 0.95em; }
        .radio-group input[type="radio"] { margin-right: 4px; cursor: pointer; vertical-align: middle; }
        .radio-options-inline { display: flex; flex-wrap: wrap; gap: 8px; align-items: center; }
        .form-check-inline { margin-right: 1rem; } .form-check { padding-left: 0; }

        .proactivity-rating-item { display: flex; align-items: center; margin-bottom: 10px; flex-wrap: wrap; }
        .proactivity-rating-item strong { min-width: 180px; display: inline-block; margin-bottom: 5px; font-size: 0.95em; }
        .proactivity-rating-item .radio-group { margin-left: 10px; }

        /* Selection Buttons */
        .selection-button { display: block; width: 90%; max-width: 600px; margin: 10px auto; padding: 12px 18px; font-size: 16px; background-color: #1877f2; color: white; border: none; border-radius: 6px; cursor: pointer; text-align: left; transition: background-color 0.3s; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .selection-button:hover { background-color: #166fe5; }
        .selection-button.completed { background-color: #28a745; border: 2px solid #1e7e34; }
        .selection-button.completed:hover { background-color: #218838; }

        /* Completion Messages & Utility */
        .all-items-completed-message { text-align: center; font-size: 1.2em; color: #28a745; margin-top: 30px; padding: 20px; border: 1px solid #c3e6cb; background-color: #d4edda; border-radius: 6px; }
        .download-all-btn { display: block; width: 300px; margin: 20px auto; padding: 12px 20px; font-size: 16px; background-color: #007bff; color: white; border: none; border-radius: 6px; cursor: pointer; }
        .download-all-btn:hover { background-color: #0056b3; }
        .text-danger { color: #dc3545 !important; }
        .text-warning { color: #ffc107 !important; }
        #firebaseStatus { font-size: 0.8em; text-align: center; margin-top: 5px; padding-bottom: 5px; }
    </style>
</head>
<body>

    <div class="main-container">

    <div class="navigation-header">
        <button class="nav-button" id="backToSelectionBtn">Back</button>
        <div class="progress-bar-container">
            <div class="progress-bar">
                <div class="progress-bar-fill" id="progressBarFill">0%</div>
            </div>
        </div>
        <button class="nav-button download-all-btn hidden" id="downloadAllResultsBtn" onclick="downloadAllFeedback()">Download Results</button>
    </div>
    <div id="firebaseStatus">Connecting to Firebase...</div>


    <div id="caseFileSelectionScreen" class="selection-screen">
        <h2>Select a Case</h2>
        <div id="caseFileButtonsContainer"></div>
    </div>

    <div id="taskSelectionScreen" class="selection-screen hidden">
        <h2 id="taskSelectionTitle">Select a Task</h2>
        <div id="taskButtonsContainer"></div>
        <div id="allTasksInFileCompletedMessage" class="all-items-completed-message hidden"></div>
    </div>

    <div id="taskDisplayScreen" class="hidden">
        <div class="task-info-display" id="taskInfoContentGlobal">
             <!-- Dynamically loaded task information -->
        </div>
        <div class="situation-prompt" id="situationPrompt">
            You will now see three different AI agent interactions based on the task above. The order of the Agents (A, B, C) has been randomized.
        </div>
        <div class="agents-container" id="agentsDisplayContainer">
            <!-- Agent columns and responses will be loaded here -->
        </div>
        <div class="evaluation-section hidden" id="evaluationFormContainer">
            <h3>Evaluation Questions</h3>
            <form id="feedbackForm">
                 <div class="evaluation-question">
                    <label class="main-label" for="annotator_id">Annotator ID:</label>
                    <input type="text" id="annotator_id" name="annotator_id" placeholder="Enter your unique ID" required>
                </div>
                <div class="evaluation-question">
                    <label class="main-label" for="rank_container">Rank the three Agent responses from Best to Worst by dragging them:</label>
                    <div class="rank-instructions">Drag to order: Best   ❯   Moderate   ❯   Worst</div>
                    <div class="rank-container" id="rank_container"></div>
                    <input type="hidden" name="ranking_order_actual_keys" id="ranking_order_actual_keys_input">
                    <input type="hidden" name="ranking_order_displayed_positions" id="ranking_order_displayed_positions_input">
                </div>
                <div class="evaluation-question">
                    <label class="main-label">Did any Agent interaction present information you consider clinically unsafe or a critical error/omission?</label>
                    <div class="radio-options-inline" id="safetyCheckboxesContainer"></div>
                    <textarea id="safety_details" name="safety_details" rows="2" placeholder="If yes, please specify which Agent (e.g., Agent A) and the issue..."></textarea>
                </div>
                <div class="evaluation-question">
                    <label class="main-label">Rate the appropriateness of proactivity/reactivity for each displayed Agent:</label>
                    <div id="proactivityRatingsContainer"></div>
                </div>
                <button type="button" class="submit-feedback-btn" onclick="submitFeedback()">Submit Annotation</button>
            </form>
        </div>
    </div>
    <div id="allCaseFilesCompletedMessage" class="all-items-completed-message hidden" style="margin-top: 30px;"></div>
</div>


<script type="module">
    // Firebase SDK
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-app.js";
    import { getFirestore, collection, doc, setDoc } from "https://www.gstatic.com/firebasejs/11.7.1/firebase-firestore.js";

    // IMPORTANT: Replace with your actual Firebase configuration
    const firebaseConfig = {
      apiKey: "__FIREBASE_API_KEY__", // Replace with your actual API key
      authDomain: "behavior-adaptation.firebaseapp.com",
      projectId: "behavior-adaptation",
      storageBucket: "behavior-adaptation.firebasestorage.app",
      messagingSenderId: "252062583138",
      appId: "1:252062583138:web:69a0d618c676a3a8f2843b",
      measurementId: "G-K93EMQ9EN2"
    };

    let app;
    let db;
    const firebaseStatusElement = document.getElementById('firebaseStatus');

    try {
         app = initializeApp(firebaseConfig);
         db = getFirestore(app);
         if (firebaseStatusElement) {
             firebaseStatusElement.textContent = "Firebase connected successfully.";
             firebaseStatusElement.style.color = 'green';
         }
         console.log("Firebase app and Firestore initialized.");
    } catch (error) {
         console.error("Firebase initialization failed:", error);
          if (firebaseStatusElement) {
               firebaseStatusElement.textContent = "Firebase connection failed. See console for details.";
               firebaseStatusElement.style.color = 'red';
           }
    }

    async function sendFeedbackToFirebase(feedbackData, annotatorId) {
        if (!db) {
            console.error("Firestore DB not initialized. Cannot send feedback.");
            alert("Error: Firebase is not connected. Feedback not saved online.");
            return;
        }
        if (!window.currentTaskFileName || !feedbackData.task_id_from_json) {
            console.error("Missing currentTaskFileName or task_id for Firebase document ID.");
            return;
        }
        // Construct a unique document ID
        const docId = `${window.currentTaskFileName.replace('.json', '')}_${feedbackData.task_id_from_json}_${annotatorId}_${new Date().getTime()}`;
        const collectionPath = "task_evaluations_prod_v2"; // Use a versioned collection if schema changes

        try {
            await setDoc(doc(db, collectionPath, docId), feedbackData);
            console.log(`Feedback saved to Firebase: Collection='${collectionPath}', DocID='${docId}'`);
        } catch (error) {
            console.error("Error sending feedback to Firebase:", error);
            alert("Error: Could not save feedback to Firebase. Please check console. Your feedback is still available for download locally.");
            // Optionally, trigger a local save here as a fallback
        }
    }

    // Expose Firebase function to global scope for the non-module script
    window.globalFirebase = { sendFeedbackToFirebase };

    // --- Configuration & Global Data (accessible to non-module script part) ---
    window.AGENT_RESPONSE_KEYS_MAP = {
        agentA: 'Type A (Behavior SFT)',
        agentB: 'Type B (General SFT)',
        agentC: 'Type C (Baseline)'
    };
    window.AGENT_INTERNAL_KEYS = ['agentA', 'agentB', 'agentC'];
    window.TASKS_OUTPUTS_DIR = "./refined_outputs/";
    window.CONVERSATIONS_DIR = "./conversations/";
    window.PDFS_DIR = "./pdfs/"; // PDF directory - commented out as not used in current display
    window.MANIFEST_FILE = window.TASKS_OUTPUTS_DIR + "manifest.json";

    window.availableTaskFiles = [];
    window.currentTaskFileName = null;
    window.taskFileMetadata = {};
    window.allTasksDataFromCurrentFile = [];
    window.displayedTasksData = []; // Filtered tasks (e.g., 1 proactive, 1 reactive)
    window.currentTaskIndexInDisplayed = -1;
    window.currentTaskData = null; // Holds the data for the currently evaluated task
    window.fullConversationData = null; // Holds the parsed _conversation.json
    window.currentAgentDisplaySetup = []; // For tracking shuffled agent display
    window.allFeedbackData = {}; // Stores all feedback for local download
    window.completedStatus = {}; // Tracks completed tasks/files: { [fileName]: { totalTasksInFile: X, totalTasksToDisplay: Y, completedDisplayedTasks: Set() } }
    window.draggedItem = null; // For drag-and-drop ranking
    window.sessionAnnotatorId = ''; // Persists annotator ID for the session

    window.onload = async () => {
        console.log("Evaluation Tool v1.9.5 (Simplified Titles) Initializing...");
        await window.loadManifestAndListTaskFiles();
        window.showTaskFileSelectionScreen();
        document.getElementById('backToSelectionBtn').disabled = true; // Initially disabled
    };
</script>

<script>
// This non-module script block contains the main UI logic.

function downloadSpecificPdf(pdfPath, downloadFileName) {
    const a = document.createElement('a');
    a.href = pdfPath;
    a.download = downloadFileName || pdfPath.split('/').pop(); // Use provided name or extract from path
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    // For direct file links, URL.revokeObjectURL is not typically needed unless you were creating a blob URL.
}
// Make it globally accessible if not already (it should be if defined in the global script block)
window.downloadSpecificPdf = downloadSpecificPdf;

async function loadManifestAndListTaskFiles() {
    try {
        const response = await fetch(window.MANIFEST_FILE);
        if (!response.ok) throw new Error(`Manifest file not found or unreadable: ${window.MANIFEST_FILE}. Status: ${response.status}`);
        const manifestData = await response.json();
        window.availableTaskFiles = manifestData.case_files || [];
        if (window.availableTaskFiles.length === 0) {
            console.warn("Manifest file loaded, but 'case_files' array is empty or missing.");
        }
    } catch (error) {
        console.error("Error loading manifest file:", error);
        alert(`Could not load the list of task files from manifest.json. Please ensure it exists at '${window.MANIFEST_FILE}' and is correctly formatted. Error: ${error.message}`);
        window.availableTaskFiles = []; // Ensure it's an empty array on error
    }
}

function showScreen(screenId) {
    ['caseFileSelectionScreen', 'taskSelectionScreen', 'taskDisplayScreen'].forEach(id => {
        document.getElementById(id).classList.add('hidden');
    });
    document.getElementById(screenId).classList.remove('hidden');
}

function getSimplifiedCaseName(fileName, index) {
    // Try to extract case number more robustly
    const match = fileName.match(/refined_(\d+)_tasks/i) || fileName.match(/case_?(\d+)/i) || fileName.match(/(\d+)/);
    return match && match[1] ? `Case ${match[1]}` : `File ${index + 1}`; // Fallback to File X
}

function showTaskFileSelectionScreen() {
    showScreen('caseFileSelectionScreen');
    const container = document.getElementById('caseFileButtonsContainer');
    container.innerHTML = ''; // Clear previous buttons
    if (window.availableTaskFiles.length === 0) {
        container.innerHTML = `<p>No task files available. Check manifest.json in ${window.TASKS_OUTPUTS_DIR} or console for errors.</p>`;
        return;
    }
    window.availableTaskFiles.forEach((fileName, index) => {
        const button = document.createElement('button');
        button.className = 'selection-button';
        button.textContent = getSimplifiedCaseName(fileName, index);
        button.onclick = () => loadTaskFileAndAssociatedConversation(fileName);
        // Check completion status
        if (window.completedStatus[fileName]?.completedDisplayedTasks.size === window.completedStatus[fileName]?.totalTasksToDisplay && window.completedStatus[fileName]?.totalTasksToDisplay > 0) {
            button.classList.add('completed');
        }
        container.appendChild(button);
    });
    document.getElementById('backToSelectionBtn').disabled = true;
    document.getElementById('backToSelectionBtn').onclick = null; // No action from this screen
    updateOverallProgressAndDownloadButton();
}

async function loadTaskFileAndAssociatedConversation(taskFileName) {
    window.currentTaskFileName = taskFileName;
    const taskFilePath = window.TASKS_OUTPUTS_DIR + taskFileName;
    window.fullConversationData = null; // Reset for new file

    try {
        const taskFileResponse = await fetch(taskFilePath);
        if (!taskFileResponse.ok) throw new Error(`HTTP error! status: ${taskFileResponse.status} for ${taskFilePath}`);
        const taskJsonData = await taskFileResponse.json();
        window.allTasksDataFromCurrentFile = taskJsonData.tasks || [];
        window.taskFileMetadata = taskJsonData.metadata || {};

        // Attempt to load conversation data
        let conversationFileId = taskJsonData.metadata?.conversation_source_details?.filename ||
                                 (taskJsonData.metadata?.conversation_source_details?.source_file_metadata?.case_id ? `${taskJsonData.metadata.conversation_source_details.source_file_metadata.case_id}_conversation.json` : null) ||
                                 (taskJsonData.metadata?.case_id?.match(/^([^_]+)/)?.[1] ? `${taskJsonData.metadata.case_id.match(/^([^_]+)/)[1]}_conversation.json` : null);

        if (!conversationFileId && taskJsonData.metadata?.conversation_source_details?.extracted_text) {
            // Try parsing embedded conversation if filename is missing
            try { window.fullConversationData = JSON.parse(taskJsonData.metadata.conversation_source_details.extracted_text); }
            catch (e) { console.error("Error parsing embedded conversation text:", e); }
        } else if (!conversationFileId) {
             console.warn("Could not determine conversation file ID from task file metadata.", taskJsonData.metadata);
        }

        if (conversationFileId && !window.fullConversationData) { // If ID found and not already parsed from embedded
            try {
                const convResponse = await fetch(window.CONVERSATIONS_DIR + conversationFileId);
                if (convResponse.ok) window.fullConversationData = await convResponse.json();
                else console.warn(`Conversation file not found or unreadable: ${window.CONVERSATIONS_DIR + conversationFileId}`);
            } catch (e) { console.warn(`Error loading conversation file ${conversationFileId}:`, e); }
        }

        // Filter tasks to display (e.g., 1 proactive, 1 reactive)
        window.displayedTasksData = [];
        const allTasks = [...window.allTasksDataFromCurrentFile]; // Work with a copy

        const proactiveTask = allTasks.find(t => t.proactive_score >= 0.6);
        if (proactiveTask) {
            window.displayedTasksData.push(proactiveTask);
            // Remove it so it's not picked again if we need a second task
            allTasks.splice(allTasks.indexOf(proactiveTask), 1);
        }

        const reactiveTask = allTasks.find(t => t.proactive_score < 0.6);
        if (reactiveTask) {
            window.displayedTasksData.push(reactiveTask);
            allTasks.splice(allTasks.indexOf(reactiveTask), 1);
        }

        // If we still have less than 2 tasks and there are more tasks available
        if (window.displayedTasksData.length < 2 && allTasks.length > 0) {
            // Add the next available task (could be another proactive if no reactive was found, or vice-versa)
            // This ensures you get up to two tasks if they exist.
            window.displayedTasksData.push(allTasks[0]);
        }
        
        window.displayedTasksData = [...window.allTasksDataFromCurrentFile];

        // Initialize or update completion status for this file
        if (!window.completedStatus[taskFileName]) {
            window.completedStatus[taskFileName] = {
                totalTasksInFile: window.allTasksDataFromCurrentFile.length,
                totalTasksToDisplay: window.displayedTasksData.length,
                completedDisplayedTasks: new Set()
            };
        } else {
            // Update totalTasksToDisplay if it changed (e.g., user chose to view all)
            window.completedStatus[taskFileName].totalTasksToDisplay = window.displayedTasksData.length;
        }
        // Initialize feedback storage for this file if not already present
        if (!window.allFeedbackData[taskFileName]) {
            window.allFeedbackData[taskFileName] = {
                taskFileMetadata: { ...window.taskFileMetadata, originalTaskFileName: taskFileName },
                tasksFeedback: {}
            };
        }
        showTaskSelectionScreenForCase();
    } catch (error) {
        console.error(`Error loading task file ${taskFileName} or its conversation:`, error);
        alert(`Failed to load data for ${taskFileName}. Error: ${error.message}`);
    }
}

function showTaskSelectionScreenForCase() {
    showScreen('taskSelectionScreen');
    const simplifiedName = getSimplifiedCaseName(window.currentTaskFileName, window.availableTaskFiles.indexOf(window.currentTaskFileName));
    document.getElementById('taskSelectionTitle').textContent = `Task List from ${simplifiedName}`;
    const container = document.getElementById('taskButtonsContainer');
    container.innerHTML = '';

    let tasksToDisplayOnScreen = [...window.displayedTasksData];
    if (tasksToDisplayOnScreen.length > 1) { 
        tasksToDisplayOnScreen = shuffleArray(tasksToDisplayOnScreen); // Shuffle for display order
    }

    if (!tasksToDisplayOnScreen || tasksToDisplayOnScreen.length === 0) {
        let msg = `<p>No selected tasks (typically 1 proactive & 1 reactive, or all if chosen) for ${simplifiedName}.`;
        msg += window.allTasksDataFromCurrentFile.length > 0 ? ` This file has ${window.allTasksDataFromCurrentFile.length} total tasks.` : ` This file has no tasks.`;
        msg += `</p>`;
        container.innerHTML = msg;
        // Option to view all tasks if not all are currently selected for display
        if (window.allTasksDataFromCurrentFile.length > 0 && window.displayedTasksData.length < window.allTasksDataFromCurrentFile.length) {
            const btn = Object.assign(document.createElement('button'), {
                textContent: `View All ${window.allTasksDataFromCurrentFile.length} Tasks Instead`,
                className: 'selection-button',
                style: 'background-color: #ffc107; color: #000;', // Warning color
                onclick: () => {
                    window.displayedTasksData = [...window.allTasksDataFromCurrentFile]; // Load all tasks
                    if(window.completedStatus[window.currentTaskFileName]) {
                        window.completedStatus[window.currentTaskFileName].totalTasksToDisplay = window.displayedTasksData.length;
                    }
                    showTaskSelectionScreenForCase(); // Re-render the screen
                }
            });
            container.appendChild(btn);
        }
    } else {
        tasksToDisplayOnScreen.forEach((task, displayIndex) => { // displayIndex is 0-based for button label
            const btn = document.createElement('button');
            btn.className = 'selection-button';
            btn.textContent = `Task ${displayIndex + 1}`; // Simple "Task X"

            btn.onclick = () => {
                // Find the original index of this task in window.displayedTasksData
                // This is important because tasksToDisplayOnScreen was shuffled
                const originalIndexInDisplayedTasks = window.displayedTasksData.findIndex(
                    originalTask => originalTask.task_id === task.task_id
                );
                if (originalIndexInDisplayedTasks !== -1) {
                    loadTaskEvaluation(originalIndexInDisplayedTasks);
                } else {
                    console.error("Could not find the selected task in the original displayedTasksData array. This should not happen.");
                    alert("Error selecting task. Please try again.");
                }
            };

            if (window.completedStatus[window.currentTaskFileName]?.completedDisplayedTasks.has(task.task_id)) {
                btn.classList.add('completed');
            }
            container.appendChild(btn);
        });
    }
    document.getElementById('backToSelectionBtn').disabled = false;
    document.getElementById('backToSelectionBtn').onclick = showTaskFileSelectionScreen;
    updateProgressBarForCurrentCase();
}

function loadTaskEvaluation(indexInDisplayedTasks) {
    window.currentTaskIndexInDisplayed = indexInDisplayedTasks;
    window.currentTaskData = window.displayedTasksData[indexInDisplayedTasks];
    if (!window.currentTaskData) {
        alert("Error: Could not load task data. `currentTaskData` is null.");
        return;
    }
    showScreen('taskDisplayScreen');

    let taskInfoHTML = '';

    // --- Build Task Information HTML ---
    taskInfoHTML += `
        <h4>Task Context Provided to AI:</h4>
        <div class="context-display">${window.currentTaskData.llm_input_context || "N/A"}</div>`;

    if (window.currentTaskData.context_hint) {
        taskInfoHTML += `<h4>Context Hint:</h4>
        <div class="context-hint-display">${window.currentTaskData.context_hint}</div>`;
    }

    taskInfoHTML += `<h4>Question Posed to AI:</h4>
        <div class="question-display">${window.currentTaskData.question || "N/A"}</div>`;

    if (window.currentTaskData.options && typeof window.currentTaskData.options === 'object') {
        taskInfoHTML += `<h4>Task Options:</h4><div class="options-display">`;
        const correctAnswerKey = window.currentTaskData.correct_answer_key;
        // Handle cases where correct_answer might be the text itself or a key
        const goldStandardAnswerText = correctAnswerKey ? window.currentTaskData.options[correctAnswerKey] : (typeof window.currentTaskData.correct_answer === 'string' ? window.currentTaskData.correct_answer : null);

        Object.entries(window.currentTaskData.options).forEach(([key, optionText]) => {
            taskInfoHTML += `<div class="option-item"><strong>${key}:</strong> ${optionText}`;
            if (goldStandardAnswerText && optionText === goldStandardAnswerText) {
                taskInfoHTML += ` <span class="correct-option">(Correct Answer)</span>`;
            }
            taskInfoHTML += `</div>`;
        });
        taskInfoHTML += `</div>`;
    }
    
    // --- Collapsible Case Details ---
        // --- PDF Download Button for Full Case Details ---
        let caseIdForPdf = null;
    if (window.fullConversationData?.case_metadata?.case_id) {
        caseIdForPdf = window.fullConversationData.case_metadata.case_id;
    } else if (window.taskFileMetadata?.case_id) { // Fallback to task file metadata
        caseIdForPdf = window.taskFileMetadata.case_id;
    } else if (window.currentTaskFileName) { // Fallback: try to extract from task file name
        const match = window.currentTaskFileName.match(/refined_(\d+)_tasks/i) || window.currentTaskFileName.match(/case_?(\d+)/i) || window.currentTaskFileName.match(/(\d+)/);
        if (match && match[1]) caseIdForPdf = match[1];
    }


    if (caseIdForPdf) {
        const pdfPath = `${window.PDFS_DIR}${caseIdForPdf}.pdf`;
        taskInfoHTML += `
            <button class="nav-button" style="margin-top: 15px; margin-bottom: 10px; background-color: #007bff; display: inline-block;" onclick="window.downloadSpecificPdf('${pdfPath}', 'Case_${caseIdForPdf}_Details.pdf')">
                Download Full Case PDF (Case ${caseIdForPdf})
            </button>`;
    } else {
        taskInfoHTML += `<p class="text-warning" style="margin-top: 15px; margin-bottom: 10px;">Full Case PDF: Case ID not found for download.</p>`;
    }

    // --- Collapsible Conversation Transcript ---
    let conversationContent = '<p class="text-warning">Conversation data not available.</p>';
    if (window.fullConversationData?.conversation && typeof window.fullConversationData.conversation === 'object') {
        // Sort turns by turn number if keys are like "turn_1", "turn_10"
        const turns = Object.entries(window.fullConversationData.conversation)
            .sort(([keyA], [keyB]) => (parseInt(keyA.split('_')[1]) || 0) - (parseInt(keyB.split('_')[1]) || 0))
            .map(([key, turn]) => `<div class="conversation-turn"><strong>${turn.speaker || 'N/A'} (Turn ${key.split('_')[1] || 'N/A'}):</strong> ${turn.message || ''}</div>`)
            .join('');
        if (turns) conversationContent = `<div class="conversation-turns-display">${turns}</div>`;
    }
    taskInfoHTML += createCollapsibleSection("Full Conversation Transcript (Click to Expand/Collapse)", conversationContent);

    document.getElementById('taskInfoContentGlobal').innerHTML = taskInfoHTML;
    addCollapsibleEventListeners(); // Re-attach listeners for new collapsible sections

    // The line that was setting evalTaskTitle.textContent has been removed as the element is gone.
    
    // Clear and reset evaluation form elements
    ['agentsDisplayContainer', 'rank_container', 'safetyCheckboxesContainer', 'proactivityRatingsContainer'].forEach(id => document.getElementById(id).innerHTML = '');
    document.getElementById('feedbackForm').reset(); // Resets form fields
    document.getElementById('safety_details').value = ''; // Explicitly clear textarea
    if (window.sessionAnnotatorId) document.getElementById('annotator_id').value = window.sessionAnnotatorId; // Pre-fill annotator ID

    document.getElementById('evaluationFormContainer').classList.remove('hidden');
    document.getElementById('backToSelectionBtn').disabled = false;
    document.getElementById('backToSelectionBtn').onclick = showTaskSelectionScreenForCase;

    presentAgentInteractions();
    updateProgressBarForCurrentCase();
}

function createCollapsibleSection(title, contentHTML, initiallyOpen = false) {
    return `
        <div class="collapsible-section">
            <div class="collapsible-header ${initiallyOpen ? 'open' : ''}">
                ${title}
                <span class="collapsible-arrow">${initiallyOpen ? '▼' : '►'}</span>
            </div>
            <div class="collapsible-content ${initiallyOpen ? 'show' : ''}">
                ${contentHTML}
            </div>
        </div>`;
}

function addCollapsibleEventListeners() {
    document.querySelectorAll('.collapsible-header').forEach(header => {
        // Remove old listener before adding a new one to prevent duplicates if this function is called multiple times
        // This is a simple way; a more robust way might involve checking if a listener already exists.
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        
        newHeader.addEventListener('click', function() {
            this.classList.toggle('open');
            const content = this.nextElementSibling;
            content.classList.toggle('show');
            this.querySelector('.collapsible-arrow').textContent = content.classList.contains('show') ? '▼' : '►';
        });
    });
}

function updateProgressBarForCurrentCase() {
    const status = window.completedStatus[window.currentTaskFileName];
    if (!status) {
        document.getElementById('progressBarFill').style.width = '0%';
        document.getElementById('progressBarFill').textContent = 'N/A';
        return;
    }
    const { totalTasksToDisplay, completedDisplayedTasks } = status;
    const percentage = totalTasksToDisplay > 0 ? (completedDisplayedTasks.size / totalTasksToDisplay) * 100 : 0;
    const progressBarFill = document.getElementById('progressBarFill');
    progressBarFill.style.width = `${percentage}%`;
    progressBarFill.textContent = `${Math.round(percentage)}% (${getSimplifiedCaseName(window.currentTaskFileName,0)} - ${completedDisplayedTasks.size}/${totalTasksToDisplay} tasks)`;
    document.getElementById('allTasksInFileCompletedMessage').classList.toggle('hidden', !(totalTasksToDisplay > 0 && percentage >= 100));
}

function updateOverallProgressAndDownloadButton() {
    const totalFiles = window.availableTaskFiles.length;
    if (totalFiles === 0) {
        document.getElementById('allCaseFilesCompletedMessage').classList.add('hidden');
        document.getElementById('downloadAllResultsBtn').classList.add('hidden');
        document.getElementById('progressBarFill').style.width = `0%`;
        document.getElementById('progressBarFill').textContent = `Load Manifest`;
        return;
    }
    const completedFilesCount = window.availableTaskFiles.filter(f => window.completedStatus[f]?.completedDisplayedTasks.size === window.completedStatus[f]?.totalTasksToDisplay && window.completedStatus[f]?.totalTasksToDisplay > 0).length;
    const allFilesDone = totalFiles > 0 && completedFilesCount === totalFiles;
    document.getElementById('allCaseFilesCompletedMessage').classList.toggle('hidden', !allFilesDone);
    document.getElementById('downloadAllResultsBtn').classList.toggle('hidden', !allFilesDone);

    // Update progress bar based on current screen
    if (!document.getElementById('caseFileSelectionScreen').classList.contains('hidden')) { // If on case selection screen
        const overallPercentage = totalFiles > 0 ? (completedFilesCount / totalFiles) * 100 : 0;
        document.getElementById('progressBarFill').style.width = `${overallPercentage}%`;
        document.getElementById('progressBarFill').textContent = `Overall: ${Math.round(overallPercentage)}% Case Files Completed`;
    }
    // The progress bar for individual case files is updated in updateProgressBarForCurrentCase()
}

function presentAgentInteractions() {
    const shuffledKeys = shuffleArray([...window.AGENT_INTERNAL_KEYS]); // Shuffle A, B, C
    window.currentAgentDisplaySetup = []; // Reset
    const displayLabels = ["A", "B", "C"]; // For UI display
    const containers = {
        agents: document.getElementById('agentsDisplayContainer'),
        rank: document.getElementById('rank_container'),
        safety: document.getElementById('safetyCheckboxesContainer'),
        proactivity: document.getElementById('proactivityRatingsContainer')
    };
    Object.values(containers).forEach(c => c.innerHTML = ''); // Clear previous content

    if (!window.currentTaskData?.llm_responses_refined) {
        containers.agents.innerHTML = "<p class='text-danger'>Error: Agent responses (`llm_responses_refined`) are missing for this task.</p>";
        return;
    }

    shuffledKeys.forEach((internalKey, index) => {
        const displayLabel = `Agent ${displayLabels[index]}`;
        // Store the mapping from display label/column to actual agent key and type
        window.currentAgentDisplaySetup.push({ 
            actualKey: internalKey, 
            actualType: window.AGENT_RESPONSE_KEYS_MAP[internalKey], 
            displayColumnLabel: displayLabels[index], 
            displayColumnIndex: index + 1 
        });

        // Create agent response column
        containers.agents.insertAdjacentHTML('beforeend', `<div class="agent-column"><div class="agent-column-header">${displayLabel}</div><div class="conversation-area" id="conv${index + 1}"></div></div>`);
        // Create rank item
        containers.rank.insertAdjacentHTML('beforeend', `<div class="rank-item" draggable="true" id="rank_item_key_${internalKey}" data-actual-agent-key="${internalKey}" data-display-label="${displayLabel}"><span class="rank-handle">☰</span> ${displayLabel}</div>`);
        // Create safety checkbox
        containers.safety.insertAdjacentHTML('beforeend', `<label class="form-check-inline"><input class="form-check-input" type="checkbox" name="safety_issue_agents_actual" value="${internalKey}"> ${displayLabel}</label>`);
        // Create proactivity rating radio buttons
        containers.proactivity.insertAdjacentHTML('beforeend', `<div class="proactivity-rating-item"><strong>${displayLabel}:</strong><div class="radio-group radio-options-inline" style="margin-left:10px;">${[1,2,3,4,5].map(v => `<label><input type="radio" name="proactivity_${internalKey}" value="${v}" required> ${v}${v===1?' (Very Inapp.)':v===3?'':v===5?' (Very Approp.)':''}</label>`).join('')}</div></div>`);

        displaySingleAgentResponseStatic(internalKey, index + 1);
    });
    setupDragAndDrop(); // Initialize drag and drop for ranking
}

function displaySingleAgentResponseStatic(internalAgentKey, displayColumnIndex) {
    const agentResponseTypeKey = window.AGENT_RESPONSE_KEYS_MAP[internalAgentKey]; // e.g., 'Type A (Behavior SFT)'
    let responseText = window.currentTaskData.llm_responses_refined?.[agentResponseTypeKey];
    if (responseText === undefined || responseText === null) {
        responseText = `<span class="text-warning">Response for '${agentResponseTypeKey}' is null or undefined.</span>`;
    }

    const convArea = document.getElementById(`conv${displayColumnIndex}`);
    if (!convArea) return;

    // Basic HTML escaping and formatting for <answer> and <rationale> tags
    let formattedText = (typeof responseText === 'string' ? responseText : JSON.stringify(responseText))
        .replace(/&/g, "&").replace(/</g, "<").replace(/>/g, ">").replace(/'/g, "'") // Escape HTML chars
        .replace(/<answer>/gi, '<strong>').replace(/<\/answer>/gi, '</strong>') // Convert <answer> to <strong>
        .replace(/<rationale>/gi, '<hr style="margin:5px 0;border-top:1px dashed #ccc;"><em>').replace(/<\/rationale>/gi, '</em>') // Convert <rationale> to <em> with <hr>
        .replace(/\n/g, '<br>'); // Convert newlines to <br>
    
    // To prevent re-interpretation of already formatted HTML (like <strong>),
    // it's generally safer to set textContent if no HTML formatting is needed from the response.
    // However, since we are intentionally formatting <answer> and <rationale>, using innerHTML is necessary here.
    // The escaping above helps mitigate basic XSS from the responseText itself.

    convArea.innerHTML = `<div class="message agent"><span class="message-emoji">🤖</span><div class="message-bubble">${formattedText}</div></div>`;
    convArea.scrollTop = convArea.scrollHeight; // Scroll to bottom
}

function setupDragAndDrop() {
    const rankContainer = document.getElementById('rank_container');
    if (!rankContainer) return;
    window.draggedItem = null; // Reset
    rankContainer.querySelectorAll('.rank-item').forEach(item => {
        item.addEventListener('dragstart', e => {
            window.draggedItem = e.target.closest('.rank-item'); // Get the draggable item
            setTimeout(() => window.draggedItem?.classList.add('dragging'), 0); // Style for dragging
        });
        item.addEventListener('dragend', () => {
            window.draggedItem?.classList.remove('dragging');
            window.draggedItem = null;
            updateRankingOrderInputs(); // Update hidden inputs with new order
        });
    });
    rankContainer.addEventListener('dragover', e => {
        e.preventDefault(); // Necessary to allow dropping
        if (!window.draggedItem) return;
        const afterElement = [...rankContainer.querySelectorAll('.rank-item:not(.dragging)')]
            .reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = e.clientX - box.left - box.width / 2; // Horizontal position relative to child center
                return (offset < 0 && offset > closest.offset) ? { offset: offset, element: child } : closest;
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        if (afterElement == null) { // If dragging beyond all items
            rankContainer.appendChild(window.draggedItem);
        } else { // Insert before the element we are hovering over
            rankContainer.insertBefore(window.draggedItem, afterElement);
        }
    });
}

function updateRankingOrderInputs() {
    const rankedItems = [...document.querySelectorAll('#rank_container .rank-item')];
    // Store the actual agent keys (agentA, agentB, agentC) in order
    document.getElementById('ranking_order_actual_keys_input').value = rankedItems.map(item => item.dataset.actualAgentKey).join(',');
    // Store the displayed labels (Agent A, Agent B, Agent C) in order for readability in feedback
    document.getElementById('ranking_order_displayed_positions_input').value = rankedItems.map(item => item.dataset.displayLabel).join(' > ');
}

async function submitFeedback() {
    updateRankingOrderInputs(); // Ensure ranking is captured
    // Basic Validations
    if (document.getElementById('ranking_order_actual_keys_input').value.split(',').length !== 3) {
        alert("Please rank all three Agent interactions uniquely by dragging them."); return;
    }
    if (!window.AGENT_INTERNAL_KEYS.every(key => document.querySelector(`input[name="proactivity_${key}"]:checked`))) {
        alert("Please rate the proactivity/reactivity for all displayed agents."); return;
    }
    const annotatorId = document.getElementById('annotator_id').value.trim();
    if (!annotatorId) {
        alert("Please enter your Annotator ID."); document.getElementById('annotator_id').focus(); return;
    }
    window.sessionAnnotatorId = annotatorId; // Store for session

    const formData = new FormData(document.getElementById('feedbackForm'));
    let feedback = {
        annotator_id: annotatorId,
        submission_timestamp: new Date().toISOString(),
        task_file_evaluated: window.currentTaskFileName,
        task_id_from_json: window.currentTaskData.task_id,
        task_question: window.currentTaskData.question,
        task_type: window.currentTaskData.task_type,
        task_llm_input_context: window.currentTaskData.llm_input_context,
        task_context_hint: window.currentTaskData.context_hint,
        task_options_provided: window.currentTaskData.options || null,
        task_correct_answer_as_per_json: window.currentTaskData.correct_answer || null,
        task_correct_answer_key_as_per_json: window.currentTaskData.correct_answer_key || null,
        initial_agent_display_order_info: window.currentAgentDisplaySetup.map(a => `${a.displayColumnLabel} (Actual: ${a.actualType}, Key: ${a.actualKey})`).join('; '),
        annotator_ranking_actual_agent_keys: formData.get('ranking_order_actual_keys'),
        annotator_ranking_displayed_labels: formData.get('ranking_order_displayed_positions'),
        safety_details: formData.get('safety_details'),
        safety_issue_for_internal_keys: formData.getAll('safety_issue_agents_actual'), // Gets array of checked values
        agent_responses_evaluated: {},
        proactivity_ratings: {},
        full_conversation_data_snapshot: window.fullConversationData?.conversation || {} // Snapshot of conversation turns
    };
    // Populate agent-specific feedback
    window.AGENT_INTERNAL_KEYS.forEach(key => {
        feedback.agent_responses_evaluated[key] = window.currentTaskData.llm_responses_refined?.[window.AGENT_RESPONSE_KEYS_MAP[key]] || "Response not found";
        feedback.proactivity_ratings[key] = formData.get(`proactivity_${key}`) ? parseInt(formData.get(`proactivity_${key}`)) : null;
    });

    // Store feedback locally
    window.allFeedbackData[window.currentTaskFileName].tasksFeedback[window.currentTaskData.task_id] = feedback;
    // Mark task as completed for this file
    window.completedStatus[window.currentTaskFileName].completedDisplayedTasks.add(window.currentTaskData.task_id);

    // Send to Firebase
    if (window.globalFirebase?.sendFeedbackToFirebase) {
        await window.globalFirebase.sendFeedbackToFirebase(feedback, annotatorId);
    } else {
        console.warn("Firebase sending function not available.");
    }
    alert(`Feedback for Task ${window.currentTaskIndexInDisplayed + 1} submitted by ${annotatorId}!`);
    showTaskSelectionScreenForCase(); // Go back to task selection for the current case
}

function downloadAllFeedback() {
    if (Object.keys(window.allFeedbackData).length === 0) {
        alert("No feedback submitted yet."); return;
    }
    const data = {
        evaluationMetadata: {
            toolVersion: "1.9.5_Simplified_Titles",
            timestamp: new Date().toISOString(),
            annotator_id: window.sessionAnnotatorId || "UNKNOWN_ANNOTATOR", // Use session ID or fallback
        },
        allTaskFilesFeedback: window.allFeedbackData
    };
    const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
    const a = Object.assign(document.createElement('a'), {
        href: URL.createObjectURL(blob),
        download: `evaluations_${data.evaluationMetadata.annotator_id}_${new Date().toISOString().slice(0,16).replace(/:/g,'')}.json` // Filename with annotator ID and timestamp
    });
    document.body.appendChild(a);
    a.click(); // Trigger download
    document.body.removeChild(a); // Clean up
    URL.revokeObjectURL(a.href); // Release object URL
}

// Utility function to shuffle an array (Fisher-Yates shuffle)
function shuffleArray(array) {
    let currentIndex = array.length, randomIndex;
    // While there remain elements to shuffle.
    while (currentIndex !== 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;
        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
            array[randomIndex], array[currentIndex]];
    }
    return array;
}
</script>
</body>
</html>
